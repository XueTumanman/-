
# 1. 传统操作系统结构

## 1.1. 无结构

**说明**
1. 早起开发的目标【功能实现，效率高】
2. = 一组过程的集合
3. 过程之间可以相互调用，OS 内部复杂混乱

## 1.2. 模块化

### 1.2.1. 模块化程序设计技术的基本概念

**说明**
1. 20 世纪 60 年代产生
2. 基于【分解，模块化】原则控制复杂度

#### 1.2.1.1. 模块接口法

**说明**
1. 按功能划分为若干个具有一定【独立性，大小】的模块
2. 模块可以在分
3. 规定各个模块的接口
4. 模块通过接口进行交互

### 1.2.2. 模块独立性

**说明**
1. 模块化 ++，模块间交互 --
2. 模块大小 --，模块复杂度 --，模块联系度 ++，系统混乱
3. 模块大小 ++，模块复杂度 ++，模块联系度 --

### 1.2.3. 衡量模块独立性

#### 1.2.3.1. 内聚性

**说明**
1. = 模块内部紧密程度，内聚性 ++，模块独立性 ++

#### 1.2.3.2. 耦合度

**说明**
1. 模块间相互影响的程度，耦合度 --，模块独立性 ++

### 1.2.4. 模块接口法的优缺点

**优点**
1. 提高 OS【正确性，可理解性，可维护性】
2. 增强 OS 可适应性
3. 加速 OS 开发过程

**缺点**
1. OS 设计时，各模块的接口设计完成后不满足实际需求
2. 各模块并行，设计无顺序，难以有可靠的基础 = 无序模块法

## 1.3. 分层式

### 1.3.1. 有序分层法

**原则**
1. 自底向上
2. 目标系统 $A_N$，逻辑系统 $A_O$ 之间铺设多层软件层
3. 每一层仅能使用底层提供的服务，【调试，验证】更容易

### 1.3.2. 分层结构优缺点

**优点**
1. 易保证 OS 正确性：设计有序，基础可靠
2. 易【扩充，维护】：增删改模块时，不改变接口，不影响其他层次

**缺点**
1. OS 效率低
2. 分层单向依赖，层次间有通信机制
3. OS 执行功能，自上而下穿越多个层次，OS 通信开销 ++

# 2. 客户/服务器模式

## 2.1. 组成

### 2.1.1. 客户机

**说明**
1. 自主计算机，有一定处理能力
2. 运行客户进程

### 2.1.2. 服务器

**说明**
1. 有【网络文件系统，数据库系统】

### 2.1.3. 网络系统
**说明**
1. 实现两者【网络通信，资源共享】

**交互过程**
1. 客户端发送请求消息：发送进程把进程消息装配成请求信息，发送给服务器
2. 服务器接收消息：服务器接收进程的状态 = 等待 $\to$ 激活，把消息提供给相应软件处理
3. 服务器回送消息：把处理结果装配成响应消息，由发送进程发送给客户机
4. 客户机接收消息：把收到的响应消息转交给客户机软件，处理后发送给请求的用户

**优点**
1. 数据的【分布处理，存储】：摆脱所有数据在主机的不可靠现象
2. 易于集中管理：重要的信息仍集中管理，较好的保障【可靠，安全】
3. 【灵活性，可扩充性】：对于客户机的程序【增，删，改】比传统模式容易得多，必要时允许客户机修改

**缺点**
1. 不可靠性：服务器 GG，全部 GG
2. 一台服务器，不够用

# 3. 面向对象程序设计

## 3.1. 面向对象技术的基本概念

- ### 对象
- ### 对象类
- ### 继承

## 3.2. 面向对象技术的优点

- ### 重用对象

  **说明**
  1. 提高产品【质量，开发效率】
  2. 降低开发成本

- ### 易【修改，扩展】

  **说明**
  1. 封装隐藏对象中的【变量，方法】，改变【变量，方法】时，不会影响到其他部分
  2. 利用继承减少开发的时空开销

- ### 易保证系统【安全，可靠】

  **说明**
  1. 对象是独立单元，可以独立测试，保证基于此的所有对象可靠
  2. 类中的信息隐藏，防止【未授权，不正当】使用

# 4. 微内核 OS 结构

**说明**
1. 有效的支持多处理机运行，适用于分布式 OS

## 4.1. 微内核 OS 基本概念

### 4.1.1. 足够小的内核

**说明**
1. 能实现现代 OS 最基本的核心功能

**包含**
1. 与硬件密切相关的部分
2. 较基本的功能
3. C/S 之间的通信

### 4.1.2. 基于 C/S 模式

**说明**
1. 将 OS 最基本功能放入微内核，大多数功能由外部进程实现
2. C/S 借助微内核提供的消息传递机制实现信息交互

### 4.1.3. 应用机制和策略分离原理

- #### 机制

  **说明**
  1. 实现某一功能的具体执行机构
  2. 在 OS 底层，微内核中

- #### 策略

  **说明**
  1. 在机制的基础上，借助【算法，参数】实现该功能的优化
  2. 在 OS 的高层

### 4.1.4. 采用面向对象技术

**说明**
1. 通过结构设计分解 OS 复杂度
2. 基于【抽象，隐蔽】原则控制 OS 的复杂性
3. 利用【封装，继承，多态】确保 OS 的【可靠性，正确性，易修改性，可扩展性】
4. 提高 OS 设计速度

## 4.2. 微内核的基本功能